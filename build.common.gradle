/**
 * build.common.gradle
 *
 * Try to avoid editing this file, as it may be updated from time to time as the FTC SDK
 * evolves. Rather, if it is necessary to customize the build process, do those edits in
 * the build.gradle file in TeamCode.
 *
 * This file contains the necessary content of the 'build.gradle' files for robot controller
 * applications built using the FTC SDK. Each individual 'build.gradle' in those applications
 * can simply contain the one line:
 *
 *      apply from: '../build.common.gradle'
 *
 * which will pick up this file here. This approach allows makes it easier to integrate
 * updates to the FTC SDK into your code.
 */

import java.util.regex.Pattern

apply plugin: 'com.android.application'

android {

    compileSdkVersion 23

    signingConfigs {
        debug {
            keyAlias 'androiddebugkey'
            keyPassword 'android'
            storeFile rootProject.file('libs/ftc.debug.keystore')
            storePassword 'android'
        }
    }

    defaultConfig {
        applicationId 'com.qualcomm.ftcrobotcontroller'
        minSdkVersion 19
        targetSdkVersion 19

        /**
         * We keep the versionCode and versionName of robot controller applications in sync with
         * the master information published in the AndroidManifest.xml file of the FtcRobotController
         * module. This helps avoid confusion that might arise from having multiple versions of
         * a robot controller app simultaneously installed on a robot controller device.
         *
         * We accomplish this with the help of a funky little Groovy script that maintains that
         * correspondence automatically.
         *
         * @see <a href="http://developer.android.com/tools/building/configuring-gradle.html">Configure Your Build</a>
         * @see <a href="http://developer.android.com/tools/publishing/versioning.html">Versioning Your App</a>
         */
        def manifestFile = project(':FtcRobotController').file('src/main/AndroidManifest.xml');
        def manifestText = manifestFile.getText()
        //
        def vCodePattern = Pattern.compile("versionCode=\"(\\d+(\\.\\d+)*)\"")
        def matcher = vCodePattern.matcher(manifestText)
        matcher.find()
        def vCode = Integer.parseInt(matcher.group(1))
        //
        def vNamePattern = Pattern.compile("versionName=\"(.*)\"")
        matcher = vNamePattern.matcher(manifestText);
        matcher.find()
        def vName = matcher.group(1)
        //
        versionCode vCode
        versionName vName
    }

    // Advanced user code might just want to use Vuforia directly, so we set up the libs as needed
    buildTypes {
        release {
            // Disable debugging for release versions so it can be uploaded to Google Play.
            //debuggable true
            ndk {
                abiFilters "armeabi-v7a"
            }
        }
        debug {
            debuggable true
            ndk {
                abiFilters "armeabi-v7a"
            }
        }
    }

    flavorDimensions 'type'
    productFlavors {
        openftc { dimension 'type' }
        stock { dimension 'type' }
    }

    // Selecting a release variant will prompt teams to set up a signing key. Now that there's
    // a reason to select other variants, better to filter out the ones that will confuse teams.
    variantFilter { variant ->
        if (variant.buildType.name == "release") {
            setIgnore(true)
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    sourceSets.main {
        jni.srcDirs = []
        jniLibs.srcDir rootProject.file('libs')
    }
}


def adbLocation = android.getAdbExecutable().absolutePath

task setupFirstFolder(type: Exec) {
    def createFirstFolderCommand = [adbLocation, 'shell', 'mkdir', '-p', '/sdcard/FIRST']
    commandLine createFirstFolderCommand

    doLast {
        exec {
            def mtpBroadcastCommand = [adbLocation, 'shell', 'am', 'broadcast', '-a',
                                       'android.intent.action.MEDIA_SCANNER_SCAN_FILE',
                                        '-d', 'file:/sdcard/FIRST']
            commandLine mtpBroadcastCommand
        }
    }
}

task pushVuforiaIfNecessary(type: Exec) {
    dependsOn(setupFirstFolder)
    def checkVuforiaCommand = [adbLocation, 'shell', 'ls', '/sdcard/FIRST/libVuforia.so']

    commandLine checkVuforiaCommand
    standardOutput = new ByteArrayOutputStream()
    errorOutput = new ByteArrayOutputStream()
    ignoreExitValue = true

    ext.vuforiaCheckOutput = {
        return standardOutput.toString()
    }
    ext.vuforiaCheckError = {
        return errorOutput.toString()
    }

    doLast {
        def vuforiaCheckExitedCleanly = (execResult.exitValue == 0)
        exec {
            workingDir '../doc/'

            def pushVuforiaCommand = [adbLocation, 'push', 'libVuforia.so', '/sdcard/FIRST']
            def combinedCheckOutput = "${vuforiaCheckOutput()}\n${vuforiaCheckError()}"
            if(combinedCheckOutput.contains("No such file")) {
                println "libVuforia.so not found on phone. Pushing!"
                commandLine pushVuforiaCommand
            } else if(vuforiaCheckExitedCleanly) {
                commandLine 'echo', 'Skipping, libVuforia already exists.'
            } else if(combinedCheckOutput.contains("no devices")) {
                commandLine 'echo', 'Skipping, no device to push to.'
            } else if(combinedCheckOutput.contains("more than one")) {
                commandLine 'echo', 'Multiple Android devices found.'
                logger.warn('\nUnable to check for libVuforia.so when multiple devices are connected.')
                logger.warn('If any connected devices do not have libVuforia.so already, they will display an error when the app starts.')
                logger.warn('If this occurs, you can simply deploy the app from Android Studio with only a single device connected.\n')
            } else {
                println combinedCheckOutput
                commandLine 'echo', 'Failed to connect to phone.'
            }
        }
    }
}

tasks.whenTaskAdded { task ->
    // I chose this task because it is never UP-TO-DATE. We should verify that that hasn't changed,
    // whenever we update the Android Gradle plugin.
    if (task.name == 'validateSigningOpenftcDebug') {
        task.dependsOn(pushVuforiaIfNecessary)
    }
}

repositories {
    flatDir {
        dirs rootProject.file('libs')
    }
}
apply from: 'build.release.gradle'
